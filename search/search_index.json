{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Smart Grid Simulator","text":"<p>The Smart Grid Simulator is a virtual power station network designed to emulate real-world power generation and distribution. It allows testing and monitoring of smart grid systems without relying on physical hardware.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Simulated Power Stations: Generate realistic power output based on configurable parameters.</li> <li>Real-Time Data Publishing: Station metadata, output, and status are continuously published via MQTT.</li> <li>Configurable &amp; Extensible: Easily set up multiple stations using environment variables or configuration files.</li> <li>Monitoring Ready: Data can be visualized through dashboards or consumed by other applications.</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Test smart grid applications safely and efficiently.</li> <li>Prototype dashboards and analytics for power monitoring.</li> <li>Simulate renewable and conventional energy sources.</li> </ul>"},{"location":"project_idea/","title":"Project Overview","text":"<p>The Smart Grid Project aims to create an intelligent energy management system that integrates multiple power stations, consumption areas, and grid management logic. The project will provide a comprehensive platform to monitor, optimize, and control energy flow, ensuring stability, efficiency, and adaptability in response to changing demand or generation conditions.</p> <p>A key component of this project is the Power Station Simulator, which models the behavior of individual power stations, including generation capacity, operational status, and real-time output. While the simulator provides realistic insights into energy production, it represents only a portion of the overall system, which will eventually include real-time sensors, IoT devices, and advanced grid management algorithms.</p> <p>The broader system will incorporate consumption zones, representing residential, commercial, and industrial energy usage. The grid management module will dynamically balance supply and demand, perform intelligent load shedding, and prioritize critical areas when necessary. Real-time monitoring, analytics, and historical trend tracking will help anticipate usage patterns, optimize distribution, and improve decision-making.</p> <p>Key points:</p> <ul> <li>Power Station Simulator for modeling generation behavior (part of the full project)</li> <li>Consumption zones simulating real-world energy usage</li> <li>Smart grid management for automated load balancing and prioritization</li> <li>Real-time monitoring, analytics, and historical trend tracking</li> <li>Scalable architecture for future integration with actual energy infrastructure</li> </ul> <p>The project\u2019s ultimate goal is to provide a flexible platform for managing and optimizing smart grids, bridging simulation with real-world deployment, and allowing incremental expansion from simulation to full system implementation.</p>"},{"location":"CodeBase/powerstation_simulator/","title":"Power Station Simulator","text":"<p>This section contains the Python API documentation for the power station simulation code.</p> <p>The following modules are documented here:</p>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.main.main","title":"<code>main()</code>","text":"<p>Main function to run the Power Station Simulator.</p> <p>This function: 1. Sets up command-line argument parsing 2. Loads configuration based on the provided station prefix 3. Initializes the station simulator with the configuration 4. Runs the simulator in an infinite loop until interrupted 5. Performs graceful shutdown on keyboard interrupt</p> Command-line arguments <p>-sp, --station-prefix: Prefix for power station-specific environment variables                       (e.g., PS_001)</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/powerstation_simulator/main.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Main function to run the Power Station Simulator.\n\n    This function:\n    1. Sets up command-line argument parsing\n    2. Loads configuration based on the provided station prefix\n    3. Initializes the station simulator with the configuration\n    4. Runs the simulator in an infinite loop until interrupted\n    5. Performs graceful shutdown on keyboard interrupt\n\n    Command-line arguments:\n        -sp, --station-prefix: Prefix for power station-specific environment variables\n                              (e.g., PS_001)\n\n    Returns:\n        None\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"\u26a1 Power Station Simulator\",\n        epilog=\"\"\"\nIMPORTANT:\n- Use the --station-prefix (or -sp) flag to load power station-specific config.\n- The required environment variables should be defined in a `.env` file or OS environment.\n- When a prefix is given, all relevant keys will be loaded with that prefix applied.\n\nSee `src/config.py` for the complete list of supported configuration fields.\n\nExamples:\n  # Load config with prefix PS_001 (looks for variables like PS_001_*)\n  python main.py --station-prefix PS_001\n\n  # Load config with prefix TEST (looks for variables like TEST_*)\n  python main.py -sp TEST\n\"\"\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        \"-sp\",\n        \"--station-prefix\",\n        type=str,\n        help=\"Prefix for power station-specific environment variables (e.g., PS_001)\",\n    )\n\n    args = parser.parse_args()\n\n    print(ps_banner)\n\n    app_config: AppConfig = load_power_station_configs(\n        station_prefix=args.station_prefix\n    )\n\n    simulator: StationSimulator = StationSimulator(app_config=app_config)\n    simulator.startup_sequence()\n    try:\n        while True:\n            sleep(1)\n    except KeyboardInterrupt:\n        simulator.shutdown_sequence()\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator","title":"<code>StationSimulator</code>","text":"<p>Simulates a power station that publishes its status, metadata, and output via MQTT.</p> <p>The simulator can be in one of two states: - Online but not running (power output is 0) - Online and running (generating power)</p> <p>The class handles MQTT communication, publishes information on regular intervals, and responds to control commands to start or stop power generation.</p> <p>Attributes:</p> Name Type Description <code>metadata_topic</code> <code>str</code> <p>Topic for publishing station metadata</p> <code>output_topic</code> <code>str</code> <p>Topic for publishing power output</p> <code>status_topic</code> <code>str</code> <p>Topic for publishing operational status</p> <code>control_topic</code> <code>str</code> <p>Topic for receiving control commands</p> Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>class StationSimulator:\n    \"\"\"\n    Simulates a power station that publishes its status, metadata, and output via MQTT.\n\n    The simulator can be in one of two states:\n    - Online but not running (power output is 0)\n    - Online and running (generating power)\n\n    The class handles MQTT communication, publishes information on regular intervals,\n    and responds to control commands to start or stop power generation.\n\n    Attributes:\n        metadata_topic (str): Topic for publishing station metadata\n        output_topic (str): Topic for publishing power output\n        status_topic (str): Topic for publishing operational status\n        control_topic (str): Topic for receiving control commands\n    \"\"\"\n\n    metadata_topic: str = \"metadata\"\n    output_topic: str = \"output\"\n    status_topic: str = \"status\"\n    control_topic: str = \"control\"\n\n    def __init__(self, app_config: AppConfig):\n        \"\"\"\n        Initialize the station simulator.\n\n        Args:\n            app_config (AppConfig): Configuration object containing MQTT settings,\n                                    power station details, and publishing intervals\n        \"\"\"\n        self.online: bool = False\n        self.running: bool = False\n        self.app_config: AppConfig = app_config\n        self.mqqt_client: MQTTClient = get_mqtt_client(app_config=app_config)\n\n    def startup_sequence(self):\n        \"\"\"\n        Start the station simulator and initialize all communication threads.\n\n        Connects to MQTT broker, subscribes to control topic, and starts\n        threads for publishing metadata, status, and power output.\n        \"\"\"\n        logger.info(\"Initializing StationSimulator startup-sequence...\")\n        self.mqqt_client.connect()\n        sleep(0.01)\n        self.online = True\n\n        # Subscribe to control channel\n        self.mqqt_client.subscribe(\n            topic=f\"{self.app_config.MQTT_TOPIC_PREFIX}/{self.app_config.POWER_STATION_ID}/{self.control_topic}\",\n            on_message=self.__handle_control,\n        )\n\n        # Start metadata + status loops\n        self.__status_thread: Thread = Thread(target=self.__publish_status_loop)\n        self.__metadata_thread: Thread = Thread(target=self.__publish_metadata_loop)\n        self.__output_thread: Thread = Thread(target=self.__publish_output_loop)\n        self.__status_thread.start()\n        self.__metadata_thread.start()\n        self.__output_thread.start()\n\n        logger.info(\"StationSimulator startup-sequence COMPLETED.\")\n\n    def shutdown_sequence(self):\n        \"\"\"\n        Safely shut down the station simulator.\n\n        Sets the station to offline state, waits for all publisher threads to complete,\n        and disconnects from MQTT broker.\n        \"\"\"\n        logger.info(\"Initializing StationSimulator shutdown-sequence...\")\n        logger.info(\"!!!...PLEASE DO NOT REPEATEDLY PRESS 'Ctrl+C' ...!!!\")\n        self.online = False\n        self.running = False\n        if hasattr(self, \"__status_thread\") and self.__status_thread.is_alive():\n            self.__status_thread.join()\n        if hasattr(self, \"__metadata_thread\") and self.__metadata_thread.is_alive():\n            self.__metadata_thread.join()\n        if hasattr(self, \"__output_thread\") and self.__output_thread.is_alive():\n            self.__output_thread.join()\n\n        self.mqqt_client.disconnect()\n        logger.info(\"StationSimulator shutdown-sequence COMPLETED.\")\n\n    def simulate_output(self) -&gt; int:\n        \"\"\"\n        Generate a simulated power output value.\n\n        Returns:\n            int: Simulated power output in kilowatts, a random value between\n                 80% and 120% of the configured capacity\n        \"\"\"\n        return int(\n            self.app_config.CAPACITY_KW * 0.8\n            + (self.app_config.CAPACITY_KW * 0.4 * random())\n        )\n\n    def publish_metadata(self):\n        \"\"\"\n        Publish the power station's metadata to MQTT.\n\n        Publishes location and capacity information to the metadata topic.\n        \"\"\"\n        self.mqqt_client.publish(\n            topic=f\"{self.app_config.MQTT_TOPIC_PREFIX}/{self.metadata_topic}/{self.app_config.POWER_STATION_ID}\",\n            payload=dict(\n                location=self.app_config.LOCATION,\n                capacity_kw=self.app_config.CAPACITY_KW,\n            ),\n        )\n\n    def publish_status(self):\n        \"\"\"\n        Publish the power station's current status to MQTT.\n\n        Status will be either \"running\" (if generating power) or \"online\" (if not generating).\n        \"\"\"\n        self.mqqt_client.publish(\n            topic=f\"{self.app_config.MQTT_TOPIC_PREFIX}/{self.app_config.POWER_STATION_ID}/{self.status_topic}\",\n            payload=\"running\" if self.running else \"online\",\n        )\n\n    def publish_output(self):\n        \"\"\"\n        Publish the current power output to MQTT.\n\n        If the station is running, publishes a simulated output value; otherwise, publishes 0.\n        \"\"\"\n        self.mqqt_client.publish(\n            topic=f\"{self.app_config.MQTT_TOPIC_PREFIX}/{self.app_config.POWER_STATION_ID}/{self.output_topic}\",\n            payload=self.simulate_output() if self.running else 0,\n        )\n\n    def __publish_metadata_loop(self):\n        \"\"\"\n        Background loop that publishes metadata at regular intervals.\n\n        Runs continuously while the station is online.\n        \"\"\"\n        while self.online:\n            self.publish_metadata()\n            sleep(self.app_config.METADATA_PUBLISH_INTERVAL_SECONDS)\n\n    def __publish_status_loop(self):\n        \"\"\"\n        Background loop that publishes status at regular intervals.\n\n        Runs continuously while the station is online.\n        \"\"\"\n        while self.online:\n            self.publish_status()\n            sleep(self.app_config.STATUS_PUBLISH_INTERVAL_SECONDS)\n\n    def __publish_output_loop(self):\n        \"\"\"\n        Background loop that publishes power output at regular intervals.\n\n        Runs continuously while the station is online.\n        \"\"\"\n        while self.online:\n            self.publish_output()\n            sleep(self.app_config.PUBLISH_INTERVAL_SECONDS)\n\n    def __handle_control(self, client: Any, userdata: Any, message: Any):\n        \"\"\"\n        Callback handler for MQTT control messages.\n\n        Parses control commands and changes the station's running state accordingly.\n\n        Args:\n            client: MQTT client instance (not used)\n            userdata: MQTT user data (not used)\n            message: MQTT message containing the control command\n        \"\"\"\n        payload = message.payload.decode()\n        logger.info(f\"Control message received: {payload}\")\n\n        normalized_command = str(payload).strip()\n\n        if normalized_command not in (\"0\", \"1\"):\n            logger.warning(f\"Unknown control command (expected '0' or '1'): {payload}\")\n            return\n\n        self.control(is_start=normalized_command == \"1\")\n\n    def control(self, is_start: bool):\n        \"\"\"\n        Change the running state of the power station.\n\n        Args:\n            is_start (bool): True to start power generation, False to stop\n        \"\"\"\n        logger.info(f\"StationSimulator is {'starting' if is_start else 'stopping'}...\")\n        self.running = is_start\n        logger.info(f\"StationSimulator {'started' if is_start else 'stopped'}.\")\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator.__handle_control","title":"<code>__handle_control(client, userdata, message)</code>","text":"<p>Callback handler for MQTT control messages.</p> <p>Parses control commands and changes the station's running state accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Any</code> <p>MQTT client instance (not used)</p> required <code>userdata</code> <code>Any</code> <p>MQTT user data (not used)</p> required <code>message</code> <code>Any</code> <p>MQTT message containing the control command</p> required Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>def __handle_control(self, client: Any, userdata: Any, message: Any):\n    \"\"\"\n    Callback handler for MQTT control messages.\n\n    Parses control commands and changes the station's running state accordingly.\n\n    Args:\n        client: MQTT client instance (not used)\n        userdata: MQTT user data (not used)\n        message: MQTT message containing the control command\n    \"\"\"\n    payload = message.payload.decode()\n    logger.info(f\"Control message received: {payload}\")\n\n    normalized_command = str(payload).strip()\n\n    if normalized_command not in (\"0\", \"1\"):\n        logger.warning(f\"Unknown control command (expected '0' or '1'): {payload}\")\n        return\n\n    self.control(is_start=normalized_command == \"1\")\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator.__init__","title":"<code>__init__(app_config)</code>","text":"<p>Initialize the station simulator.</p> <p>Parameters:</p> Name Type Description Default <code>app_config</code> <code>AppConfig</code> <p>Configuration object containing MQTT settings,                     power station details, and publishing intervals</p> required Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>def __init__(self, app_config: AppConfig):\n    \"\"\"\n    Initialize the station simulator.\n\n    Args:\n        app_config (AppConfig): Configuration object containing MQTT settings,\n                                power station details, and publishing intervals\n    \"\"\"\n    self.online: bool = False\n    self.running: bool = False\n    self.app_config: AppConfig = app_config\n    self.mqqt_client: MQTTClient = get_mqtt_client(app_config=app_config)\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator.__publish_metadata_loop","title":"<code>__publish_metadata_loop()</code>","text":"<p>Background loop that publishes metadata at regular intervals.</p> <p>Runs continuously while the station is online.</p> Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>def __publish_metadata_loop(self):\n    \"\"\"\n    Background loop that publishes metadata at regular intervals.\n\n    Runs continuously while the station is online.\n    \"\"\"\n    while self.online:\n        self.publish_metadata()\n        sleep(self.app_config.METADATA_PUBLISH_INTERVAL_SECONDS)\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator.__publish_output_loop","title":"<code>__publish_output_loop()</code>","text":"<p>Background loop that publishes power output at regular intervals.</p> <p>Runs continuously while the station is online.</p> Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>def __publish_output_loop(self):\n    \"\"\"\n    Background loop that publishes power output at regular intervals.\n\n    Runs continuously while the station is online.\n    \"\"\"\n    while self.online:\n        self.publish_output()\n        sleep(self.app_config.PUBLISH_INTERVAL_SECONDS)\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator.__publish_status_loop","title":"<code>__publish_status_loop()</code>","text":"<p>Background loop that publishes status at regular intervals.</p> <p>Runs continuously while the station is online.</p> Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>def __publish_status_loop(self):\n    \"\"\"\n    Background loop that publishes status at regular intervals.\n\n    Runs continuously while the station is online.\n    \"\"\"\n    while self.online:\n        self.publish_status()\n        sleep(self.app_config.STATUS_PUBLISH_INTERVAL_SECONDS)\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator.control","title":"<code>control(is_start)</code>","text":"<p>Change the running state of the power station.</p> <p>Parameters:</p> Name Type Description Default <code>is_start</code> <code>bool</code> <p>True to start power generation, False to stop</p> required Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>def control(self, is_start: bool):\n    \"\"\"\n    Change the running state of the power station.\n\n    Args:\n        is_start (bool): True to start power generation, False to stop\n    \"\"\"\n    logger.info(f\"StationSimulator is {'starting' if is_start else 'stopping'}...\")\n    self.running = is_start\n    logger.info(f\"StationSimulator {'started' if is_start else 'stopped'}.\")\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator.publish_metadata","title":"<code>publish_metadata()</code>","text":"<p>Publish the power station's metadata to MQTT.</p> <p>Publishes location and capacity information to the metadata topic.</p> Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>def publish_metadata(self):\n    \"\"\"\n    Publish the power station's metadata to MQTT.\n\n    Publishes location and capacity information to the metadata topic.\n    \"\"\"\n    self.mqqt_client.publish(\n        topic=f\"{self.app_config.MQTT_TOPIC_PREFIX}/{self.metadata_topic}/{self.app_config.POWER_STATION_ID}\",\n        payload=dict(\n            location=self.app_config.LOCATION,\n            capacity_kw=self.app_config.CAPACITY_KW,\n        ),\n    )\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator.publish_output","title":"<code>publish_output()</code>","text":"<p>Publish the current power output to MQTT.</p> <p>If the station is running, publishes a simulated output value; otherwise, publishes 0.</p> Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>def publish_output(self):\n    \"\"\"\n    Publish the current power output to MQTT.\n\n    If the station is running, publishes a simulated output value; otherwise, publishes 0.\n    \"\"\"\n    self.mqqt_client.publish(\n        topic=f\"{self.app_config.MQTT_TOPIC_PREFIX}/{self.app_config.POWER_STATION_ID}/{self.output_topic}\",\n        payload=self.simulate_output() if self.running else 0,\n    )\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator.publish_status","title":"<code>publish_status()</code>","text":"<p>Publish the power station's current status to MQTT.</p> <p>Status will be either \"running\" (if generating power) or \"online\" (if not generating).</p> Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>def publish_status(self):\n    \"\"\"\n    Publish the power station's current status to MQTT.\n\n    Status will be either \"running\" (if generating power) or \"online\" (if not generating).\n    \"\"\"\n    self.mqqt_client.publish(\n        topic=f\"{self.app_config.MQTT_TOPIC_PREFIX}/{self.app_config.POWER_STATION_ID}/{self.status_topic}\",\n        payload=\"running\" if self.running else \"online\",\n    )\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator.shutdown_sequence","title":"<code>shutdown_sequence()</code>","text":"<p>Safely shut down the station simulator.</p> <p>Sets the station to offline state, waits for all publisher threads to complete, and disconnects from MQTT broker.</p> Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>def shutdown_sequence(self):\n    \"\"\"\n    Safely shut down the station simulator.\n\n    Sets the station to offline state, waits for all publisher threads to complete,\n    and disconnects from MQTT broker.\n    \"\"\"\n    logger.info(\"Initializing StationSimulator shutdown-sequence...\")\n    logger.info(\"!!!...PLEASE DO NOT REPEATEDLY PRESS 'Ctrl+C' ...!!!\")\n    self.online = False\n    self.running = False\n    if hasattr(self, \"__status_thread\") and self.__status_thread.is_alive():\n        self.__status_thread.join()\n    if hasattr(self, \"__metadata_thread\") and self.__metadata_thread.is_alive():\n        self.__metadata_thread.join()\n    if hasattr(self, \"__output_thread\") and self.__output_thread.is_alive():\n        self.__output_thread.join()\n\n    self.mqqt_client.disconnect()\n    logger.info(\"StationSimulator shutdown-sequence COMPLETED.\")\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator.simulate_output","title":"<code>simulate_output()</code>","text":"<p>Generate a simulated power output value.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Simulated power output in kilowatts, a random value between  80% and 120% of the configured capacity</p> Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>def simulate_output(self) -&gt; int:\n    \"\"\"\n    Generate a simulated power output value.\n\n    Returns:\n        int: Simulated power output in kilowatts, a random value between\n             80% and 120% of the configured capacity\n    \"\"\"\n    return int(\n        self.app_config.CAPACITY_KW * 0.8\n        + (self.app_config.CAPACITY_KW * 0.4 * random())\n    )\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.station_simulator.StationSimulator.startup_sequence","title":"<code>startup_sequence()</code>","text":"<p>Start the station simulator and initialize all communication threads.</p> <p>Connects to MQTT broker, subscribes to control topic, and starts threads for publishing metadata, status, and power output.</p> Source code in <code>src/powerstation_simulator/station_simulator.py</code> <pre><code>def startup_sequence(self):\n    \"\"\"\n    Start the station simulator and initialize all communication threads.\n\n    Connects to MQTT broker, subscribes to control topic, and starts\n    threads for publishing metadata, status, and power output.\n    \"\"\"\n    logger.info(\"Initializing StationSimulator startup-sequence...\")\n    self.mqqt_client.connect()\n    sleep(0.01)\n    self.online = True\n\n    # Subscribe to control channel\n    self.mqqt_client.subscribe(\n        topic=f\"{self.app_config.MQTT_TOPIC_PREFIX}/{self.app_config.POWER_STATION_ID}/{self.control_topic}\",\n        on_message=self.__handle_control,\n    )\n\n    # Start metadata + status loops\n    self.__status_thread: Thread = Thread(target=self.__publish_status_loop)\n    self.__metadata_thread: Thread = Thread(target=self.__publish_metadata_loop)\n    self.__output_thread: Thread = Thread(target=self.__publish_output_loop)\n    self.__status_thread.start()\n    self.__metadata_thread.start()\n    self.__output_thread.start()\n\n    logger.info(\"StationSimulator startup-sequence COMPLETED.\")\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.mqtt_client.MQTTClient","title":"<code>MQTTClient</code>","text":"<p>A client for connecting to an MQTT broker and publishing/subscribing to topics.</p> <p>This class provides methods to connect to an MQTT broker, publish messages, subscribe to topics, and handle connection events.</p> Source code in <code>src/powerstation_simulator/mqtt_client.py</code> <pre><code>class MQTTClient:\n    \"\"\"\n    A client for connecting to an MQTT broker and publishing/subscribing to topics.\n\n    This class provides methods to connect to an MQTT broker, publish messages,\n    subscribe to topics, and handle connection events.\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id: str,\n        host: str,\n        port: int,\n        username: str,\n        password: str,\n        enable_websocket: bool,\n    ):\n        \"\"\"\n        Initialize an MQTT client.\n\n        Args:\n            client_id (str): Unique identifier for this client\n            host (str): MQTT broker hostname or IP address\n            port (int): MQTT broker port\n            username (str): Authentication username\n            password (str): Authentication password\n            enable_websocket (bool): Use websockets instead of TCP if True\n        \"\"\"\n        self.host: str = host\n        self.port: int = port\n        self.connected: bool = False\n\n        self.client: mqtt_client.Client = mqtt_client.Client(\n            client_id=f\"{client_id}_\".join(choices(ascii_letters + digits, k=6)),\n            transport=\"websockets\" if enable_websocket else \"tcp\",\n        )\n        if username and password:\n            self.client.username_pw_set(username, password)\n\n        self.client.on_connect = self.on_connect\n        self.client.on_disconnect = self.on_disconnect\n\n    def connect(self):\n        \"\"\"\n        Connect to the MQTT broker and start the network loop.\n        \"\"\"\n        self.client.connect(self.host, self.port)\n        self.client.loop_start()\n\n    def disconnect(self):\n        \"\"\"\n        Disconnect from the MQTT broker and stop the network loop.\n        \"\"\"\n        self.client.loop_stop()\n        self.client.disconnect()\n\n    def on_connect(\n        self, client: mqtt_client.Client, userdata: Any, flags: dict, rc: int\n    ) -&gt; None:\n        \"\"\"\n        Callback for when the client connects to the broker.\n\n        Args:\n            client: The client instance\n            userdata: User data of any type\n            flags: Response flags sent by the broker\n            rc (int): Connection result code\n        \"\"\"\n        if rc == 0:\n            self.connected = True\n            logger.info(f\"Connected to MQTT broker at {self.host}:{self.port}\")\n        else:\n            logger.error(f\"Failed to connect, return code {rc}\")\n\n    def on_disconnect(self, client: mqtt_client.Client, userdata: Any, rc: int) -&gt; None:\n        \"\"\"\n        Callback for when the client disconnects from the broker.\n\n        Args:\n            client: The client instance\n            userdata: User data of any type\n            rc (int): Disconnection result code\n        \"\"\"\n        self.connected = False\n        logger.info(\"Disconnected from MQTT broker\")\n\n    def publish(self, topic: str, payload: Any, qos: int = 1) -&gt; bool:\n        \"\"\"\n        Publish a message to a topic.\n\n        Args:\n            topic (str): The topic to publish to\n            payload (Any): The message to publish (dictionaries will be JSON-encoded)\n            qos (int, optional): Quality of Service level. Defaults to 1.\n\n        Returns:\n            bool: True if the message was published successfully, False otherwise\n        \"\"\"\n        if not self.connected:\n            logger.warning(\"MQTT client not connected. Cannot publish.\")\n            return False\n\n        result = self.client.publish(\n            topic=topic,\n            payload=dumps(payload) if isinstance(payload, dict) else payload,\n            qos=qos,\n        )\n\n        if not result.rc:\n            logger.debug(f\"Published to topic {topic}: {payload}\")\n            return True\n        logger.error(f\"Failed to publish to topic {topic}\")\n        return False\n\n    def subscribe(\n        self, topic: str, qos: int = 1, on_message: Any | None = None\n    ) -&gt; None:\n        \"\"\"\n        Subscribe to a topic.\n\n        Args:\n            topic (str): The topic to subscribe to\n            qos (int, optional): Quality of Service level. Defaults to 1.\n            on_message (callable, optional): Callback for when a message is received.\n                If None, a default handler will be used.\n        \"\"\"\n\n        def __on_message(client, userdata, msg):\n            logger.info(f\"Received message on {msg.topic}: {msg.payload.decode()}\")\n\n        self.client.subscribe(topic, qos=qos)\n        self.client.on_message = on_message or __on_message\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.mqtt_client.MQTTClient.__init__","title":"<code>__init__(client_id, host, port, username, password, enable_websocket)</code>","text":"<p>Initialize an MQTT client.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Unique identifier for this client</p> required <code>host</code> <code>str</code> <p>MQTT broker hostname or IP address</p> required <code>port</code> <code>int</code> <p>MQTT broker port</p> required <code>username</code> <code>str</code> <p>Authentication username</p> required <code>password</code> <code>str</code> <p>Authentication password</p> required <code>enable_websocket</code> <code>bool</code> <p>Use websockets instead of TCP if True</p> required Source code in <code>src/powerstation_simulator/mqtt_client.py</code> <pre><code>def __init__(\n    self,\n    client_id: str,\n    host: str,\n    port: int,\n    username: str,\n    password: str,\n    enable_websocket: bool,\n):\n    \"\"\"\n    Initialize an MQTT client.\n\n    Args:\n        client_id (str): Unique identifier for this client\n        host (str): MQTT broker hostname or IP address\n        port (int): MQTT broker port\n        username (str): Authentication username\n        password (str): Authentication password\n        enable_websocket (bool): Use websockets instead of TCP if True\n    \"\"\"\n    self.host: str = host\n    self.port: int = port\n    self.connected: bool = False\n\n    self.client: mqtt_client.Client = mqtt_client.Client(\n        client_id=f\"{client_id}_\".join(choices(ascii_letters + digits, k=6)),\n        transport=\"websockets\" if enable_websocket else \"tcp\",\n    )\n    if username and password:\n        self.client.username_pw_set(username, password)\n\n    self.client.on_connect = self.on_connect\n    self.client.on_disconnect = self.on_disconnect\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.mqtt_client.MQTTClient.connect","title":"<code>connect()</code>","text":"<p>Connect to the MQTT broker and start the network loop.</p> Source code in <code>src/powerstation_simulator/mqtt_client.py</code> <pre><code>def connect(self):\n    \"\"\"\n    Connect to the MQTT broker and start the network loop.\n    \"\"\"\n    self.client.connect(self.host, self.port)\n    self.client.loop_start()\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.mqtt_client.MQTTClient.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from the MQTT broker and stop the network loop.</p> Source code in <code>src/powerstation_simulator/mqtt_client.py</code> <pre><code>def disconnect(self):\n    \"\"\"\n    Disconnect from the MQTT broker and stop the network loop.\n    \"\"\"\n    self.client.loop_stop()\n    self.client.disconnect()\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.mqtt_client.MQTTClient.on_connect","title":"<code>on_connect(client, userdata, flags, rc)</code>","text":"<p>Callback for when the client connects to the broker.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The client instance</p> required <code>userdata</code> <code>Any</code> <p>User data of any type</p> required <code>flags</code> <code>dict</code> <p>Response flags sent by the broker</p> required <code>rc</code> <code>int</code> <p>Connection result code</p> required Source code in <code>src/powerstation_simulator/mqtt_client.py</code> <pre><code>def on_connect(\n    self, client: mqtt_client.Client, userdata: Any, flags: dict, rc: int\n) -&gt; None:\n    \"\"\"\n    Callback for when the client connects to the broker.\n\n    Args:\n        client: The client instance\n        userdata: User data of any type\n        flags: Response flags sent by the broker\n        rc (int): Connection result code\n    \"\"\"\n    if rc == 0:\n        self.connected = True\n        logger.info(f\"Connected to MQTT broker at {self.host}:{self.port}\")\n    else:\n        logger.error(f\"Failed to connect, return code {rc}\")\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.mqtt_client.MQTTClient.on_disconnect","title":"<code>on_disconnect(client, userdata, rc)</code>","text":"<p>Callback for when the client disconnects from the broker.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Client</code> <p>The client instance</p> required <code>userdata</code> <code>Any</code> <p>User data of any type</p> required <code>rc</code> <code>int</code> <p>Disconnection result code</p> required Source code in <code>src/powerstation_simulator/mqtt_client.py</code> <pre><code>def on_disconnect(self, client: mqtt_client.Client, userdata: Any, rc: int) -&gt; None:\n    \"\"\"\n    Callback for when the client disconnects from the broker.\n\n    Args:\n        client: The client instance\n        userdata: User data of any type\n        rc (int): Disconnection result code\n    \"\"\"\n    self.connected = False\n    logger.info(\"Disconnected from MQTT broker\")\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.mqtt_client.MQTTClient.publish","title":"<code>publish(topic, payload, qos=1)</code>","text":"<p>Publish a message to a topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The topic to publish to</p> required <code>payload</code> <code>Any</code> <p>The message to publish (dictionaries will be JSON-encoded)</p> required <code>qos</code> <code>int</code> <p>Quality of Service level. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the message was published successfully, False otherwise</p> Source code in <code>src/powerstation_simulator/mqtt_client.py</code> <pre><code>def publish(self, topic: str, payload: Any, qos: int = 1) -&gt; bool:\n    \"\"\"\n    Publish a message to a topic.\n\n    Args:\n        topic (str): The topic to publish to\n        payload (Any): The message to publish (dictionaries will be JSON-encoded)\n        qos (int, optional): Quality of Service level. Defaults to 1.\n\n    Returns:\n        bool: True if the message was published successfully, False otherwise\n    \"\"\"\n    if not self.connected:\n        logger.warning(\"MQTT client not connected. Cannot publish.\")\n        return False\n\n    result = self.client.publish(\n        topic=topic,\n        payload=dumps(payload) if isinstance(payload, dict) else payload,\n        qos=qos,\n    )\n\n    if not result.rc:\n        logger.debug(f\"Published to topic {topic}: {payload}\")\n        return True\n    logger.error(f\"Failed to publish to topic {topic}\")\n    return False\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.mqtt_client.MQTTClient.subscribe","title":"<code>subscribe(topic, qos=1, on_message=None)</code>","text":"<p>Subscribe to a topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The topic to subscribe to</p> required <code>qos</code> <code>int</code> <p>Quality of Service level. Defaults to 1.</p> <code>1</code> <code>on_message</code> <code>callable</code> <p>Callback for when a message is received. If None, a default handler will be used.</p> <code>None</code> Source code in <code>src/powerstation_simulator/mqtt_client.py</code> <pre><code>def subscribe(\n    self, topic: str, qos: int = 1, on_message: Any | None = None\n) -&gt; None:\n    \"\"\"\n    Subscribe to a topic.\n\n    Args:\n        topic (str): The topic to subscribe to\n        qos (int, optional): Quality of Service level. Defaults to 1.\n        on_message (callable, optional): Callback for when a message is received.\n            If None, a default handler will be used.\n    \"\"\"\n\n    def __on_message(client, userdata, msg):\n        logger.info(f\"Received message on {msg.topic}: {msg.payload.decode()}\")\n\n    self.client.subscribe(topic, qos=qos)\n    self.client.on_message = on_message or __on_message\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.mqtt_client.get_mqtt_client","title":"<code>get_mqtt_client(app_config)</code>","text":"<p>Create and return an MQTT client using configuration from the application settings.</p> <p>This function initializes an MQTTClient instance with connection parameters extracted from the provided AppConfig object.</p> <p>Parameters:</p> Name Type Description Default <code>app_config</code> <code>AppConfig</code> <p>Application configuration containing MQTT connection settings</p> required <p>Returns:</p> Name Type Description <code>MQTTClient</code> <code>MQTTClient</code> <p>A configured MQTT client instance ready for connection</p> Source code in <code>src/powerstation_simulator/mqtt_client.py</code> <pre><code>def get_mqtt_client(app_config: AppConfig) -&gt; MQTTClient:\n    \"\"\"\n    Create and return an MQTT client using configuration from the application settings.\n\n    This function initializes an MQTTClient instance with connection parameters\n    extracted from the provided AppConfig object.\n\n    Args:\n        app_config (AppConfig): Application configuration containing MQTT connection settings\n\n    Returns:\n        MQTTClient: A configured MQTT client instance ready for connection\n    \"\"\"\n    return MQTTClient(\n        client_id=app_config.POWER_STATION_ID,\n        host=app_config.MQTT_HOST,\n        port=app_config.MQTT_PORT,\n        username=app_config.MQTT_USERNAME,\n        password=app_config.MQTT_PASSWORD,\n        enable_websocket=app_config.ENABLE_WEBSOCKET,\n    )\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.config.AppConfig","title":"<code>AppConfig</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>AppConfig is the main configuration class for the power station application.</p> <p>This class defines all the necessary configuration parameters for the application, including station metadata, MQTT broker settings, and simulator configurations. It uses Pydantic's BaseSettings for environment variable loading and validation.</p> <p>Environment variables are loaded from a .env.sample file by default.</p> Source code in <code>src/powerstation_simulator/config.py</code> <pre><code>class AppConfig(BaseSettings):\n    \"\"\"\n    AppConfig is the main configuration class for the power station application.\n\n    This class defines all the necessary configuration parameters for the application,\n    including station metadata, MQTT broker settings, and simulator configurations.\n    It uses Pydantic's BaseSettings for environment variable loading and validation.\n\n    Environment variables are loaded from a .env.sample file by default.\n    \"\"\"\n\n    model_config = SettingsConfigDict(\n        env_file=\".env.sample\",\n        env_file_encoding=\"utf-8\",\n        validate_by_name=False,\n        case_sensitive=True,\n        extra=\"ignore\",\n    )\n\n    # Metadata (static info)\n    POWER_STATION_ID: Annotated[str, Field()] = \"PS_001\"\n    LOCATION: Annotated[str, Field()] = \"Dhaka, Bangladesh\"\n    CAPACITY_KW: Annotated[int, Field()] = 1000\n\n    # MQTT broker config\n    MQTT_HOST: Annotated[str, Field()] = \"127.0.0.1\"\n    MQTT_PORT: Annotated[int, Field()] = 1883\n    MQTT_USERNAME: Annotated[str, Field()] = \"extinctcoder\"\n    MQTT_PASSWORD: Annotated[str, Field()] = \"Mosquitto123456#\"\n    MQTT_TOPIC_PREFIX: Annotated[str, Field()] = \"smartgrid/powerstation\"\n\n    ENABLE_WEBSOCKET: Annotated[bool, Field()] = False\n\n    # Simulator settings\n    PUBLISH_INTERVAL_SECONDS: Annotated[int, Field()] = 1\n\n    STATUS_PUBLISH_INTERVAL_SECONDS: int = PUBLISH_INTERVAL_SECONDS * 2\n    METADATA_PUBLISH_INTERVAL_SECONDS: int = PUBLISH_INTERVAL_SECONDS * 5\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.config.load_power_station_configs","title":"<code>load_power_station_configs(station_prefix=None)</code>","text":"<p>Dynamically loads the config for a specific power station prefix, e.g., 'PS_001'. If no prefix is provided explicitly, reads from the STATION_PREFIX env var.</p> Source code in <code>src/powerstation_simulator/config.py</code> <pre><code>def load_power_station_configs(station_prefix: str | None = None) -&gt; AppConfig:\n    \"\"\"\n    Dynamically loads the config for a specific power station prefix, e.g., 'PS_001'.\n    If no prefix is provided explicitly, reads from the STATION_PREFIX env var.\n    \"\"\"\n    station_prefix = station_prefix or getenv(\"STATION_PREFIX\")\n\n    logger.info(f\"Simple Power Station SIMULATOR serving station : {station_prefix}\")\n\n    if not station_prefix:\n        return AppConfig()  # fallback to default or global settings\n\n    class AppConfigWithPrefix(AppConfig):\n        model_config = {\n            **AppConfig.model_config,\n            \"env_prefix\": station_prefix.upper().replace(\"-\", \"_\") + \"_\",\n        }\n\n    return AppConfigWithPrefix()\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.logger.ColoredFormatter","title":"<code>ColoredFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>A custom logging formatter that adds color to log level names in terminal output.</p> <p>This formatter wraps the log level name with ANSI color codes based on the severity level. Colors are defined in the COLORS dictionary.</p> <p>Methods:</p> Name Description <code>format</code> <p>Overrides the base Formatter's format method to add colors.</p> Source code in <code>src/powerstation_simulator/logger.py</code> <pre><code>class ColoredFormatter(logging.Formatter):\n    \"\"\"\n    A custom logging formatter that adds color to log level names in terminal output.\n\n    This formatter wraps the log level name with ANSI color codes based on the\n    severity level. Colors are defined in the COLORS dictionary.\n\n    Methods:\n        format: Overrides the base Formatter's format method to add colors.\n    \"\"\"\n\n    def format(self, record: LogRecord) -&gt; str:\n        \"\"\"\n        Format the specified record with colored level names.\n\n        Args:\n            record: A LogRecord object containing all the information\n                   needed to generate a log message.\n\n        Returns:\n            str: The formatted log message with colored level name.\n        \"\"\"\n        color = COLORS.get(record.levelname, COLORS[\"RESET\"])\n        record.levelname = f\"{color}{record.levelname}{COLORS['RESET']}\"\n        return super().format(record)\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.logger.ColoredFormatter.format","title":"<code>format(record)</code>","text":"<p>Format the specified record with colored level names.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>A LogRecord object containing all the information    needed to generate a log message.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted log message with colored level name.</p> Source code in <code>src/powerstation_simulator/logger.py</code> <pre><code>def format(self, record: LogRecord) -&gt; str:\n    \"\"\"\n    Format the specified record with colored level names.\n\n    Args:\n        record: A LogRecord object containing all the information\n               needed to generate a log message.\n\n    Returns:\n        str: The formatted log message with colored level name.\n    \"\"\"\n    color = COLORS.get(record.levelname, COLORS[\"RESET\"])\n    record.levelname = f\"{color}{record.levelname}{COLORS['RESET']}\"\n    return super().format(record)\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.logger.getLogger","title":"<code>getLogger(name)</code>","text":"<p>Get a logger with the specified name, ensuring the base logger is configured.</p> <p>This function calls setup_base_logger() to ensure that logging is properly configured with colored output, then returns a logger with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A string that identifies the logger.</p> required <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: A configured logger instance with the specified name.</p> Source code in <code>src/powerstation_simulator/logger.py</code> <pre><code>def getLogger(name: str) -&gt; Logger:\n    \"\"\"\n    Get a logger with the specified name, ensuring the base logger is configured.\n\n    This function calls setup_base_logger() to ensure that logging is properly\n    configured with colored output, then returns a logger with the given name.\n\n    Args:\n        name: A string that identifies the logger.\n\n    Returns:\n        logging.Logger: A configured logger instance with the specified name.\n    \"\"\"\n    setup_base_logger()\n    return logging.getLogger(name)\n</code></pre>"},{"location":"CodeBase/powerstation_simulator/#powerstation_simulator.logger.setup_base_logger","title":"<code>setup_base_logger(level=logging.DEBUG)</code>","text":"<p>Configure and return the root logger with colored output.</p> <p>This function sets up the root logger with a StreamHandler that outputs to stdout and formats messages using the ColoredFormatter. If the root logger already has handlers configured, this function does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | str</code> <p>The logging level to set for the root logger. Default is logging.DEBUG.</p> <code>DEBUG</code> <p>Returns:</p> Name Type Description <code>Logger</code> <code>Logger</code> <p>The configured root logger instance.</p> Source code in <code>src/powerstation_simulator/logger.py</code> <pre><code>def setup_base_logger(level: int | str = logging.DEBUG) -&gt; Logger:\n    \"\"\"\n    Configure and return the root logger with colored output.\n\n    This function sets up the root logger with a StreamHandler that outputs\n    to stdout and formats messages using the ColoredFormatter. If the root\n    logger already has handlers configured, this function does nothing.\n\n    Args:\n        level:\n            The logging level to set for the root logger.\n            Default is logging.DEBUG.\n\n    Returns:\n        Logger: The configured root logger instance.\n    \"\"\"\n    root_logger = logging.getLogger()\n    if not root_logger.hasHandlers():\n        root_logger.setLevel(level)\n        handler = logging.StreamHandler(sys.stdout)\n        handler.setFormatter(\n            ColoredFormatter(\"%(asctime)s %(filename)s: %(levelname)s, %(message)s\")\n        )\n        root_logger.addHandler(handler)\n        root_logger.propagate = False\n    return root_logger\n</code></pre>"}]}